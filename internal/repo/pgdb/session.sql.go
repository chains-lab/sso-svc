// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: session.sql

package pgdb

import (
	"context"

	"github.com/google/uuid"
)

const countSessionsByAccountID = `-- name: CountSessionsByAccountID :one
SELECT count(*)
FROM sessions
WHERE account_id = $1
`

func (q *Queries) CountSessionsByAccountID(ctx context.Context, accountID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessionsByAccountID, accountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: createSession :one
INSERT INTO sessions (id, account_id, hash_token)
VALUES ($1, $2, $3)
RETURNING id, account_id, hash_token, last_used, created_at
`

type CreateSessionParams struct {
	ID        uuid.UUID
	AccountID uuid.UUID
	HashToken string
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.ID, arg.AccountID, arg.HashToken)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.HashToken,
		&i.LastUsed,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAccountSession = `-- name: DeleteAccountSession :exec
DELETE FROM sessions
WHERE account_id = $1
  AND id = $2
`

type DeleteAccountSessionParams struct {
	AccountID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) DeleteAccountSession(ctx context.Context, arg DeleteAccountSessionParams) error {
	_, err := q.db.ExecContext(ctx, deleteAccountSession, arg.AccountID, arg.ID)
	return err
}

const deleteSessionByID = `-- name: DeleteSessionByID :exec
DELETE FROM sessions
WHERE id = $1
`

func (q *Queries) DeleteSessionByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSessionByID, id)
	return err
}

const deleteSessionsByAccountID = `-- name: DeleteSessionsByAccountID :exec
DELETE FROM sessions
WHERE account_id = $1
`

func (q *Queries) DeleteSessionsByAccountID(ctx context.Context, accountID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSessionsByAccountID, accountID)
	return err
}

const getAccountSession = `-- name: GetAccountSession :one
SELECT id, account_id, hash_token, last_used, created_at
FROM sessions
WHERE account_id = $1
  AND id = $2
`

type GetAccountSessionParams struct {
	AccountID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) GetAccountSession(ctx context.Context, arg GetAccountSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, getAccountSession, arg.AccountID, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.HashToken,
		&i.LastUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, account_id, hash_token, last_used, created_at FROM sessions
WHERE id = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.HashToken,
		&i.LastUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionsByAccountID = `-- name: GetSessionsByAccountID :many
SELECT id, account_id, hash_token, last_used, created_at
FROM sessions
WHERE account_id = $1
ORDER BY created_at DESC, id DESC
    LIMIT $2
OFFSET $3
`

type GetSessionsByAccountIDParams struct {
	AccountID uuid.UUID
	Limit     int32
	Offset    int32
}

func (q *Queries) GetSessionsByAccountID(ctx context.Context, arg GetSessionsByAccountIDParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsByAccountID, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.HashToken,
			&i.LastUsed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSessionToken = `-- name: UpdateSessionToken :one
UPDATE sessions
SET hash_token = $2, last_used = NOW()
WHERE id = $1
RETURNING id, account_id, hash_token, last_used, created_at
`

type UpdateSessionTokenParams struct {
	ID        uuid.UUID
	HashToken string
}

func (q *Queries) UpdateSessionToken(ctx context.Context, arg UpdateSessionTokenParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, updateSessionToken, arg.ID, arg.HashToken)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.HashToken,
		&i.LastUsed,
		&i.CreatedAt,
	)
	return i, err
}
